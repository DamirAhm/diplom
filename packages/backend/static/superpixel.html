<!DOCTYPE html>
<html lang="ru">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Демонстрация алгоритма разбиения изображения на мазки</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        h1 {
            text-align: center;
            margin-bottom: 30px;
        }

        .container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
        }

        .control-panel {
            flex: 1;
            min-width: 300px;
            padding: 20px;
            border: 1px solid #ccc;
            border-radius: 5px;
        }

        .image-area {
            flex: 2;
            min-width: 500px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .image-container {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .canvas-box {
            flex: 1;
            border: 1px solid #eee;
            padding: 10px;
            border-radius: 5px;
            text-align: center;
        }

        .canvas-box canvas {
            max-width: 100%;
            display: block;
            margin: 0 auto;
            border: 1px solid #ddd;
        }

        .form-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }

        input[type="range"] {
            width: 100%;
        }

        input[type="file"] {
            margin-top: 10px;
        }

        button {
            background-color: #4CAF50;
            color: white;
            padding: 10px 15px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            width: 100%;
            margin-bottom: 10px;
        }

        button:hover {
            background-color: #45a049;
        }

        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }

        .value-display {
            display: inline-block;
            min-width: 30px;
            text-align: right;
        }

        .loading {
            display: none;
            text-align: center;
            margin-top: 20px;
            font-style: italic;
            color: #666;
        }

        .animation-controls {
            display: flex;
            gap: 10px;
            margin-top: 10px;
            justify-content: center;
        }

        .animation-controls button {
            width: auto;
        }

        .stroke-info {
            margin-top: 20px;
            padding: 10px;
            border-top: 1px solid #eee;
        }

        .stats {
            font-size: 14px;
            margin-top: 10px;
            color: #666;
        }
    </style>
</head>

<body>
    <h1>Демонстрация алгоритма разбиения изображения на мазки</h1>

    <div class="container">
        <div class="control-panel">
            <h2>Параметры алгоритма</h2>
            <form id="processForm">
                <div class="form-group">
                    <label for="numberOfSuperpixels">Количество мазков: <span id="numberOfSuperpixelsValue"
                            class="value-display">100</span></label>
                    <input type="range" id="numberOfSuperpixels" name="numberOfSuperpixels" min="10" max="5000"
                        value="100">
                </div>

                <div class="form-group">
                    <label for="compactnessFactor">Компактность: <span id="compactnessFactorValue"
                            class="value-display">20</span></label>
                    <input type="range" id="compactnessFactor" name="compactnessFactor" min="1" max="100" value="20">
                </div>

                <div class="form-group">
                    <label for="elongation">Вытянутость (p): <span id="elongationValue"
                            class="value-display">2.0</span></label>
                    <input type="range" id="elongation" name="elongation" min="1" max="10" step="0.1" value="2.0">
                </div>

                <div class="form-group">
                    <label for="iterations">Количество итераций: <span id="iterationsValue"
                            class="value-display">10</span></label>
                    <input type="range" id="iterations" name="iterations" min="1" max="30" value="10">
                </div>

                <div class="form-group">
                    <label for="gridSize">Размер сетки градиентов: <span id="gridSizeValue"
                            class="value-display">20</span></label>
                    <input type="range" id="gridSize" name="gridSize" min="5" max="30" value="20">
                </div>

                <div class="form-group">
                    <label for="imageFile">Выберите изображение:</label>
                    <input type="file" id="imageFile" name="imageFile" accept="image/jpeg, image/png">
                </div>

                <button type="submit" id="processButton">Обработать изображение</button>
            </form>

            <div class="loading" id="loadingIndicator">
                Обработка изображения... Это может занять несколько секунд.
            </div>

            <div class="animation-controls">
                <button id="animateButton" disabled>Анимировать рисование</button>
                <button id="resetButton" disabled>Сбросить</button>
            </div>

            <div class="stroke-info">
                <h3>Статистика</h3>
                <div id="stats" class="stats">
                    Загрузите изображение для обработки...
                </div>
            </div>
        </div>

        <div class="image-area">
            <h2>Результаты</h2>
            <div class="image-container">
                <div class="canvas-box">
                    <h3>Исходное изображение</h3>
                    <canvas id="originalCanvas"></canvas>
                </div>
                <div class="canvas-box">
                    <h3>Мазки</h3>
                    <canvas id="strokesCanvas"></canvas>
                </div>
                <div class="canvas-box">
                    <h3>Визуализация градиентов</h3>
                    <canvas id="gradientsCanvas"></canvas>
                    <div class="form-group">
                        <label>
                            <input type="checkbox" id="showGradients" checked>
                            Показать направления градиентов
                        </label>
                    </div>
                </div>
            </div>

            <div>
                <h3>Описание алгоритма:</h3>
                <p>
                    Этот алгоритм является модификацией классического алгоритма разбиения изображения на суперпиксели
                    SLIC.
                    Основное отличие заключается в использовании нормалей к градиентам для создания вытянутых мазков.
                </p>
                <p>
                    Вместо стандартной метрики расстояния используется эллиптическая метрика:
                    X² + (pY)² ≤ d², где p > 1 - параметр вытянутости.
                </p>
                <p>
                    Это позволяет суперпикселям расти в p раз быстрее вдоль нормалей к градиенту, чем в ортогональном
                    направлении,
                    создавая эффект мазков кисти, следующих за контурами объектов на изображении.
                </p>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function () {
            const form = document.getElementById('processForm');
            const loadingIndicator = document.getElementById('loadingIndicator');
            const originalCanvas = document.getElementById('originalCanvas');
            const strokesCanvas = document.getElementById('strokesCanvas');
            const gradientsCanvas = document.getElementById('gradientsCanvas');
            const showGradientsCheckbox = document.getElementById('showGradients');
            const animateButton = document.getElementById('animateButton');
            const resetButton = document.getElementById('resetButton');
            const statsDiv = document.getElementById('stats');

            const originalCtx = originalCanvas.getContext('2d');
            const strokesCtx = strokesCanvas.getContext('2d');
            const gradientsCtx = gradientsCanvas.getContext('2d');

            let originalImage = new Image();
            let strokeData = null;
            let animationFrame = null;
            let animationIndex = 0;
            let animationSpeed = 5; // Мазков за кадр
            let scaleX = 1; // Масштаб по X
            let scaleY = 1; // Масштаб по Y

            // Update slider value displays
            const sliders = ['numberOfSuperpixels', 'compactnessFactor', 'elongation', 'iterations', 'gridSize'];
            sliders.forEach(sliderId => {
                const slider = document.getElementById(sliderId);
                const valueDisplay = document.getElementById(sliderId + 'Value');

                valueDisplay.textContent = slider.value;
                slider.addEventListener('input', function () {
                    valueDisplay.textContent = this.value;
                });
            });

            // Preview selected image
            document.getElementById('imageFile').addEventListener('change', function (e) {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = function (e) {
                        originalImage.src = e.target.result;
                        originalImage.onload = function () {
                            // Resize canvas to match image dimensions with max width/height constraints
                            const maxWidth = 800;
                            const maxHeight = 600;
                            let width = originalImage.width;
                            let height = originalImage.height;

                            if (width > maxWidth) {
                                height = (maxWidth / width) * height;
                                width = maxWidth;
                            }

                            if (height > maxHeight) {
                                width = (maxHeight / height) * width;
                                height = maxHeight;
                            }

                            // Set canvas size
                            originalCanvas.width = width;
                            originalCanvas.height = height;
                            strokesCanvas.width = width;
                            strokesCanvas.height = height;
                            gradientsCanvas.width = width;
                            gradientsCanvas.height = height;

                            // Вычисляем масштаб
                            scaleX = width / originalImage.width;
                            scaleY = height / originalImage.height;

                            // Draw original image
                            originalCtx.clearRect(0, 0, width, height);
                            originalCtx.drawImage(originalImage, 0, 0, width, height);

                            // Clear strokes canvas
                            strokesCtx.clearRect(0, 0, width, height);

                            // Reset animation related state
                            strokeData = null;
                            animationIndex = 0;
                            if (animationFrame) {
                                cancelAnimationFrame(animationFrame);
                                animationFrame = null;
                            }

                            animateButton.disabled = true;
                            resetButton.disabled = true;
                        };
                    };
                    reader.readAsDataURL(file);
                }
            });

            // Form submission
            form.addEventListener('submit', function (e) {
                e.preventDefault();

                if (!originalImage.src) {
                    alert('Пожалуйста, выберите изображение');
                    return;
                }

                const formData = new FormData();
                const imageFile = document.getElementById('imageFile').files[0];

                if (!imageFile) {
                    alert('Пожалуйста, выберите изображение');
                    return;
                }

                // Add image file to FormData
                formData.append('image', imageFile);

                // Add parameters as JSON
                const params = {
                    numberOfSuperpixels: parseInt(document.getElementById('numberOfSuperpixels').value),
                    compactnessFactor: parseFloat(document.getElementById('compactnessFactor').value),
                    elongation: parseFloat(document.getElementById('elongation').value),
                    iterations: parseInt(document.getElementById('iterations').value),
                    gridSize: parseInt(document.getElementById('gridSize').value)
                };

                formData.append('params', JSON.stringify(params));

                // Show loading indicator
                loadingIndicator.style.display = 'block';
                document.getElementById('processButton').disabled = true;
                animateButton.disabled = true;
                resetButton.disabled = true;

                // Send request to API
                fetch('/api/image/superpixels', {
                    method: 'POST',
                    body: formData
                })
                    .then(response => {
                        if (!response.ok) {
                            throw new Error('Ошибка обработки: ' + response.statusText);
                        }
                        return response.json();
                    })
                    .then(data => {
                        // Store stroke data
                        strokeData = data;

                        // Clear strokes canvas
                        strokesCtx.clearRect(0, 0, strokesCanvas.width, strokesCanvas.height);

                        // Draw all strokes at once initially
                        drawAllStrokes(strokesCtx, strokeData.strokes);

                        // Draw gradient vectors if checkbox is checked
                        if (showGradientsCheckbox.checked && strokeData.gridVectors) {
                            drawGradientVectors(gradientsCtx, strokeData.gridVectors);
                        }

                        // Update stats
                        updateStats(strokeData);

                        // Enable animation controls
                        animateButton.disabled = false;
                        resetButton.disabled = false;
                    })
                    .catch(error => {
                        console.error('Error:', error);
                        alert('Произошла ошибка при обработке изображения: ' + error.message);
                    })
                    .finally(() => {
                        // Hide loading indicator
                        loadingIndicator.style.display = 'none';
                        document.getElementById('processButton').disabled = false;
                    });
            });

            // Animation button
            animateButton.addEventListener('click', function () {
                if (!strokeData) return;

                // Reset canvas
                strokesCtx.clearRect(0, 0, strokesCanvas.width, strokesCanvas.height);

                // Reset animation index
                animationIndex = 0;

                // Start animation
                animateStrokes();

                // Disable button during animation
                animateButton.disabled = true;
            });

            // Reset button
            resetButton.addEventListener('click', function () {
                if (!strokeData) return;

                // Stop any ongoing animation
                if (animationFrame) {
                    cancelAnimationFrame(animationFrame);
                    animationFrame = null;
                }

                // Reset canvas
                strokesCtx.clearRect(0, 0, strokesCanvas.width, strokesCanvas.height);

                // Draw all strokes
                drawAllStrokes(strokesCtx, strokeData.strokes);

                // Redraw gradient vectors if needed
                if (showGradientsCheckbox.checked && strokeData.gridVectors) {
                    gradientsCtx.clearRect(0, 0, gradientsCanvas.width, gradientsCanvas.height);
                    drawGradientVectors(gradientsCtx, strokeData.gridVectors);
                }

                // Enable animation button
                animateButton.disabled = false;
            });

            // Toggle gradient vectors display
            showGradientsCheckbox.addEventListener('change', function () {
                if (!strokeData || !strokeData.gridVectors) return;

                gradientsCtx.clearRect(0, 0, gradientsCanvas.width, gradientsCanvas.height);

                if (this.checked) {
                    drawGradientVectors(gradientsCtx, strokeData.gridVectors);
                }
            });

            // Function to animate strokes
            function animateStrokes() {
                if (animationIndex < strokeData.strokes.length) {
                    // Рисуем все мазки текущей цветовой группы
                    const currentGroup = strokeData.strokes[animationIndex].colorGroup;
                    let endIndex = animationIndex;

                    // Находим все мазки текущей цветовой группы
                    while (endIndex < strokeData.strokes.length &&
                        strokeData.strokes[endIndex].colorGroup === currentGroup) {
                        endIndex++;
                    }

                    // Рисуем мазки группы с учетом скорости анимации
                    let batchEndIndex = Math.min(animationIndex + animationSpeed, endIndex);

                    for (let i = animationIndex; i < batchEndIndex; i++) {
                        drawStroke(strokesCtx, strokeData.strokes[i]);
                    }

                    animationIndex = batchEndIndex;

                    // Если закончили группу и ещё есть место для других мазков этого кадра, сразу переходим к следующей группе
                    if (animationIndex === endIndex &&
                        endIndex < strokeData.strokes.length &&
                        (endIndex - animationIndex) < animationSpeed) {

                        // Продолжаем анимацию без задержки
                        animationFrame = requestAnimationFrame(animateStrokes);
                    } else {
                        // Продолжаем анимацию с задержкой между кадрами
                        setTimeout(() => {
                            animationFrame = requestAnimationFrame(animateStrokes);
                        }, 10); // Небольшая задержка между кадрами для плавности
                    }
                } else {
                    // Анимация завершена
                    animationFrame = null;
                    animateButton.disabled = false;
                }
            }

            // Function to draw a single stroke
            function drawStroke(ctx, stroke) {
                ctx.fillStyle = `rgb(${stroke.color[0]}, ${stroke.color[1]}, ${stroke.color[2]})`;

                // Draw each pixel in the stroke
                for (const pixel of stroke.pixels) {
                    // Масштабируем координаты
                    const x = Math.floor(pixel[0] * scaleX);
                    const y = Math.floor(pixel[1] * scaleY);

                    // Используем размер кисти в зависимости от масштаба
                    const brushSize = Math.max(1, Math.min(scaleX, scaleY));
                    if (brushSize <= 1) {
                        ctx.fillRect(x, y, 1, 1);
                    } else {
                        // Используем закругленную кисть для более эстетичного результата
                        ctx.beginPath();
                        ctx.arc(x, y, brushSize / 2, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            }

            // Function to draw all strokes at once
            function drawAllStrokes(ctx, strokes) {
                for (const stroke of strokes) {
                    drawStroke(ctx, stroke);
                }
            }

            // Function to update statistics
            function updateStats(data) {
                // Определяем количество цветовых групп
                const numColorGroups = data.strokes.length > 0 ?
                    Math.max(...data.strokes.map(s => s.colorGroup)) + 1 : 0;

                statsDiv.innerHTML = `
                    Размер изображения: ${data.imageWidth} x ${data.imageHeight}<br>
                    Количество мазков: ${data.strokes.length}<br>
                    Количество цветовых групп: ${numColorGroups}<br>
                    Средний размер мазка: ${Math.round(data.strokes.reduce((sum, s) => sum + s.pixels.length, 0) / data.strokes.length)} пикселей<br>
                `;
            }

            // Add slider for animation speed
            const speedControl = document.createElement('div');
            speedControl.className = 'form-group';
            speedControl.innerHTML = `
                <label for="animationSpeed">Скорость анимации: <span id="animationSpeedValue" class="value-display">${animationSpeed}</span></label>
                <input type="range" id="animationSpeed" min="1" max="50" value="${animationSpeed}">
            `;

            document.querySelector('.animation-controls').parentNode.insertBefore(
                speedControl,
                document.querySelector('.animation-controls')
            );

            const speedSlider = document.getElementById('animationSpeed');
            const speedDisplay = document.getElementById('animationSpeedValue');

            speedSlider.addEventListener('input', function () {
                animationSpeed = parseInt(this.value);
                speedDisplay.textContent = animationSpeed;
            });

            // Function to draw gradient vectors
            function drawGradientVectors(ctx, vectors) {
                // Сначала копируем исходное изображение для контекста
                ctx.drawImage(originalCanvas, 0, 0);

                // Делаем изображение полупрозрачным
                ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);

                // Рисуем каждый вектор
                for (const vector of vectors) {
                    // Масштабируем координаты
                    const x = Math.floor(vector.x * scaleX);
                    const y = Math.floor(vector.y * scaleY);

                    // Вычисляем длину линии вектора (10-30 пикселей, зависит от magnitude)
                    const lineLength = 10 + vector.length * 20;

                    // Вычисляем конечную точку вектора
                    const endX = x + Math.cos(vector.theta) * lineLength;
                    const endY = y + Math.sin(vector.theta) * lineLength;

                    // Рисуем линию вектора
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    ctx.lineTo(endX, endY);
                    ctx.strokeStyle = 'rgba(0, 100, 255, 0.7)';
                    ctx.lineWidth = 1.5;
                    ctx.stroke();

                    // Рисуем наконечник стрелки
                    const arrowSize = 5;
                    const angle = vector.theta;

                    ctx.beginPath();
                    ctx.moveTo(endX, endY);
                    ctx.lineTo(
                        endX - arrowSize * Math.cos(angle - Math.PI / 6),
                        endY - arrowSize * Math.sin(angle - Math.PI / 6)
                    );
                    ctx.lineTo(
                        endX - arrowSize * Math.cos(angle + Math.PI / 6),
                        endY - arrowSize * Math.sin(angle + Math.PI / 6)
                    );
                    ctx.closePath();
                    ctx.fillStyle = 'rgba(0, 100, 255, 0.9)';
                    ctx.fill();

                    // Рисуем точку начала вектора
                    ctx.beginPath();
                    ctx.arc(x, y, 2, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(255, 0, 0, 0.7)';
                    ctx.fill();
                }
            }
        });
    </script>
</body>

</html>