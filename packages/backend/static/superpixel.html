<!DOCTYPE html>
<html lang="ru">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Демонстрация алгоритма разбиения изображения на мазки</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        h1 {
            text-align: center;
            margin-bottom: 30px;
        }

        .container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
        }

        .control-panel {
            flex: 1;
            min-width: 300px;
            padding: 20px;
            border: 1px solid #ccc;
            border-radius: 5px;
        }

        .image-area {
            flex: 2;
            min-width: 500px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .image-container {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .canvas-box {
            flex: 1;
            border: 1px solid #eee;
            padding: 10px;
            border-radius: 5px;
            text-align: center;
        }

        .canvas-box canvas {
            max-width: 100%;
            display: block;
            margin: 0 auto;
            border: 1px solid #ddd;
        }

        .form-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }

        input[type="range"] {
            width: 100%;
        }

        input[type="file"] {
            margin-top: 10px;
        }

        button {
            background-color: #4CAF50;
            color: white;
            padding: 10px 15px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            width: 100%;
            margin-bottom: 10px;
        }

        button:hover {
            background-color: #45a049;
        }

        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }

        .value-display {
            display: inline-block;
            min-width: 30px;
            text-align: right;
        }

        .loading {
            display: none;
            text-align: center;
            margin-top: 20px;
            font-style: italic;
            color: #666;
        }

        .animation-controls {
            display: flex;
            gap: 10px;
            margin-top: 10px;
            justify-content: center;
        }

        .animation-controls button {
            width: auto;
        }

        .stroke-info {
            margin-top: 20px;
            padding: 10px;
            border-top: 1px solid #eee;
        }

        .stats {
            font-size: 14px;
            margin-top: 10px;
            color: #666;
        }

        .checkbox-label {
            display: inline-block;
            margin-left: 10px;
        }
    </style>
</head>

<body>
    <h1>Демонстрация алгоритма разбиения изображения на мазки</h1>

    <div class="container">
        <div class="control-panel">
            <h2>Параметры алгоритма</h2>
            <form id="processForm">
                <div class="form-group">
                    <label for="numberOfSuperpixels">Количество мазков: <span id="numberOfSuperpixelsValue"
                            class="value-display">100</span></label>
                    <input type="range" id="numberOfSuperpixels" name="numberOfSuperpixels" min="10" max="5000"
                        value="100">
                </div>

                <div class="form-group">
                    <label for="compactnessFactor">Компактность: <span id="compactnessFactorValue"
                            class="value-display">20</span></label>
                    <input type="range" id="compactnessFactor" name="compactnessFactor" min="1" max="100" value="20">
                </div>

                <div class="form-group">
                    <label for="elongation">Вытянутость (p): <span id="elongationValue"
                            class="value-display">2.0</span></label>
                    <input type="range" id="elongation" name="elongation" min="1" max="10" step="0.1" value="2.0">
                </div>

                <div class="form-group">
                    <label for="iterations">Количество итераций: <span id="iterationsValue"
                            class="value-display">10</span></label>
                    <input type="range" id="iterations" name="iterations" min="1" max="30" value="10">
                </div>

                <div class="form-group">
                    <label for="gridSize">Размер сетки градиентов: <span id="gridSizeValue"
                            class="value-display">20</span></label>
                    <input type="range" id="gridSize" name="gridSize" min="5" max="30" value="20">
                </div>

                <div class="form-group">
                    <label for="adaptiveFactor">Адаптивное распределение: <span id="adaptiveFactorValue"
                            class="value-display">0.5</span></label>
                    <input type="range" id="adaptiveFactor" name="adaptiveFactor" min="0" max="1" step="0.1"
                        value="0.5">
                </div>

                <div class="form-group">
                    <label for="imageFile">Выберите изображение:</label>
                    <input type="file" id="imageFile" name="imageFile" accept="image/jpeg, image/png">
                </div>

                <button type="submit" id="processButton">Обработать изображение</button>
            </form>

            <div class="loading" id="loadingIndicator">
                Обработка изображения... Это может занять несколько секунд.
            </div>

            <div class="animation-controls">
                <button id="animateButton" disabled>Анимировать рисование</button>
                <button id="resetButton" disabled>Сбросить</button>
            </div>

            <div class="stroke-info">
                <h3>Статистика</h3>
                <div id="stats" class="stats">
                    Загрузите изображение для обработки...
                </div>
            </div>

            <div class="stroke-info">
                <h3>Отладка кластера</h3>
                <div id="clusterDebug" class="stats">
                    Наведите курсор на мазок для отладки...
                </div>
            </div>
        </div>

        <div class="image-area">
            <h2>Результаты</h2>
            <div class="image-container">
                <div class="canvas-box">
                    <h3>Исходное изображение</h3>
                    <canvas id="originalCanvas"></canvas>
                </div>
                <div class="canvas-box">
                    <h3>Мазки</h3>
                    <canvas id="strokesCanvas"></canvas>
                </div>
                <div class="canvas-box">
                    <h3>Визуализация градиентов</h3>
                    <canvas id="gradientsCanvas"></canvas>
                    <div class="form-group">
                        <label class="checkbox-label">
                            <input type="checkbox" id="showGradients">
                            Показать направления
                        </label>
                        <label class="checkbox-label">
                            <input type="checkbox" id="showCenters">
                            Показать центры кластеров
                        </label>
                        <label class="checkbox-label">
                            <input type="checkbox" id="showColorGradient">
                            Показать цветовой градиент
                        </label>
                    </div>
                    <div class="form-group gradient-sensitivity" style="display: none; margin-top: 10px;">
                        <label for="gradientSensitivity">Чувствительность градиента: <span id="gradientSensitivityValue"
                                class="value-display">1.0</span></label>
                        <input type="range" id="gradientSensitivity" min="0.1" max="2.0" step="0.1" value="1.0">
                    </div>
                </div>
            </div>

            <div>
                <h3>Описание алгоритма:</h3>
                <p>
                    Этот алгоритм является модификацией классического алгоритма разбиения изображения на суперпиксели
                    SLIC.
                    Основное отличие заключается в использовании нормалей к градиентам для создания вытянутых мазков.
                </p>
                <p>
                    Вместо стандартной метрики расстояния используется эллиптическая метрика:
                    X² + (pY)² ≤ d², где p > 1 - параметр вытянутости.
                </p>
                <p>
                    Это позволяет суперпикселям расти в p раз быстрее вдоль нормалей к градиенту, чем в ортогональном
                    направлении,
                    создавая эффект мазков кисти, следующих за контурами объектов на изображении.
                </p>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function () {
            const form = document.getElementById('processForm');
            const loadingIndicator = document.getElementById('loadingIndicator');
            const originalCanvas = document.getElementById('originalCanvas');
            const strokesCanvas = document.getElementById('strokesCanvas');
            const gradientsCanvas = document.getElementById('gradientsCanvas');
            const showGradientsCheckbox = document.getElementById('showGradients');
            const showCentersCheckbox = document.getElementById('showCenters');
            const showColorGradientCheckbox = document.getElementById('showColorGradient');
            const animateButton = document.getElementById('animateButton');
            const resetButton = document.getElementById('resetButton');
            const statsDiv = document.getElementById('stats');
            const clusterDebugDiv = document.getElementById('clusterDebug');
            const gradientSensitivitySlider = document.getElementById('gradientSensitivity');
            const gradientSensitivityValue = document.getElementById('gradientSensitivityValue');
            const gradientSensitivityContainer = document.querySelector('.gradient-sensitivity');

            const originalCtx = originalCanvas.getContext('2d');
            const strokesCtx = strokesCanvas.getContext('2d');
            const gradientsCtx = gradientsCanvas.getContext('2d');

            const highlightCanvas = document.createElement('canvas'); // Создаем холст для выделения программно
            const highlightCtx = highlightCanvas.getContext('2d');
            highlightCanvas.id = 'highlightCanvas';
            highlightCanvas.style.position = 'absolute';
            highlightCanvas.style.top = '78px';
            highlightCanvas.style.left = '78px';
            highlightCanvas.style.pointerEvents = 'none';
            highlightCanvas.style.border = '1px solid transparent';

            // Добавляем холст выделения поверх холста мазков
            const strokesContainer = strokesCanvas.parentElement;
            strokesContainer.style.position = 'relative';
            strokesContainer.appendChild(highlightCanvas);

            let originalImage = new Image();
            let strokeData = null;
            let highlightedStrokeId = null; // ID выделенного мазка
            let animationFrame = null;
            let animationIndex = 0;
            let animationSpeed = 5; // Мазков за кадр
            let scaleX = 1; // Масштаб по X
            let scaleY = 1; // Масштаб по Y

            // Update slider value displays
            const sliders = ['numberOfSuperpixels', 'compactnessFactor', 'elongation', 'iterations', 'gridSize', 'adaptiveFactor'];
            sliders.forEach(sliderId => {
                const slider = document.getElementById(sliderId);
                const valueDisplay = document.getElementById(sliderId + 'Value');

                valueDisplay.textContent = slider.value;
                slider.addEventListener('input', function () {
                    valueDisplay.textContent = this.value;
                });
            });

            // Preview selected image
            document.getElementById('imageFile').addEventListener('change', function (e) {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = function (e) {
                        originalImage.src = e.target.result;
                        originalImage.onload = function () {
                            // Resize canvas to match image dimensions with max width/height constraints
                            const maxWidth = 800;
                            const maxHeight = 600;
                            let width = originalImage.width;
                            let height = originalImage.height;

                            if (width > maxWidth) {
                                height = (maxWidth / width) * height;
                                width = maxWidth;
                            }

                            if (height > maxHeight) {
                                width = (maxHeight / height) * width;
                                height = maxHeight;
                            }

                            // Set canvas size
                            originalCanvas.width = width;
                            originalCanvas.height = height;
                            strokesCanvas.width = width;
                            strokesCanvas.height = height;
                            gradientsCanvas.width = width;
                            gradientsCanvas.height = height;
                            highlightCanvas.width = width;
                            highlightCanvas.height = height;

                            // Вычисляем масштаб
                            scaleX = width / originalImage.width;
                            scaleY = height / originalImage.height;

                            // Draw original image
                            originalCtx.clearRect(0, 0, width, height);
                            originalCtx.drawImage(originalImage, 0, 0, width, height);

                            // Clear strokes canvas
                            strokesCtx.clearRect(0, 0, width, height);

                            // Reset animation related state
                            strokeData = null;
                            animationIndex = 0;
                            if (animationFrame) {
                                cancelAnimationFrame(animationFrame);
                                animationFrame = null;
                            }

                            animateButton.disabled = true;
                            resetButton.disabled = true;
                        };
                    };
                    reader.readAsDataURL(file);
                }
            });

            // Form submission
            form.addEventListener('submit', function (e) {
                e.preventDefault();

                if (!originalImage.src) {
                    alert('Пожалуйста, выберите изображение');
                    return;
                }

                const formData = new FormData();
                const imageFile = document.getElementById('imageFile').files[0];

                if (!imageFile) {
                    alert('Пожалуйста, выберите изображение');
                    return;
                }

                // Add image file to FormData
                formData.append('image', imageFile);

                // Add parameters as JSON
                const params = {
                    numberOfSuperpixels: parseInt(document.getElementById('numberOfSuperpixels').value),
                    compactnessFactor: parseFloat(document.getElementById('compactnessFactor').value),
                    elongation: parseFloat(document.getElementById('elongation').value),
                    iterations: parseInt(document.getElementById('iterations').value),
                    gridSize: parseInt(document.getElementById('gridSize').value),
                    adaptiveFactor: parseFloat(document.getElementById('adaptiveFactor').value)
                };

                formData.append('params', JSON.stringify(params));

                // Show loading indicator
                loadingIndicator.style.display = 'block';
                document.getElementById('processButton').disabled = true;
                animateButton.disabled = true;
                resetButton.disabled = true;

                // Send request to API
                fetch('/api/image/superpixels', {
                    method: 'POST',
                    body: formData
                })
                    .then(response => {
                        if (!response.ok) {
                            throw new Error('Ошибка обработки: ' + response.statusText);
                        }
                        return response.json();
                    })
                    .then(data => {
                        // Store stroke data
                        strokeData = data;

                        // Clear strokes canvas
                        strokesCtx.clearRect(0, 0, strokesCanvas.width, strokesCanvas.height);

                        // Draw all strokes at once initially
                        drawAllStrokes(strokesCtx, strokeData.strokes);

                        // Update gradients view based on checkbox states
                        updateGradientsView();

                        // Update stats
                        updateStats(strokeData);

                        // Enable animation controls
                        animateButton.disabled = false;
                        resetButton.disabled = false;
                    })
                    .catch(error => {
                        console.error('Error:', error);
                        alert('Произошла ошибка при обработке изображения: ' + error.message);
                    })
                    .finally(() => {
                        // Hide loading indicator
                        loadingIndicator.style.display = 'none';
                        document.getElementById('processButton').disabled = false;
                    });
            });

            // Reset button
            resetButton.addEventListener('click', function () {
                if (animationFrame) {
                    cancelAnimationFrame(animationFrame);
                    animationFrame = null;
                }

                // Сбрасываем индекс анимации
                animationIndex = 0;

                // Очищаем холст мазков
                strokesCtx.clearRect(0, 0, strokesCanvas.width, strokesCanvas.height);

                // Перерисовываем все мазки
                if (strokeData && strokeData.strokes) {
                    drawAllStrokes(strokesCtx, strokeData.strokes);
                }

                // Обновляем отображение градиентов и центров
                gradientsCtx.clearRect(0, 0, gradientsCanvas.width, gradientsCanvas.height);
                if (showGradientsCheckbox.checked && strokeData && strokeData.gridVectors) {
                    drawGradientVectors(gradientsCtx, strokeData.gridVectors);
                }
                if (showCentersCheckbox.checked && strokeData && strokeData.strokes) {
                    drawClusterCenters(gradientsCtx, strokeData.strokes);
                }

                // Сброс выделения
                highlightCtx.clearRect(0, 0, highlightCanvas.width, highlightCanvas.height);
                highlightedStrokeId = null;
                updateDebugInfo(null);

                // Разблокируем кнопку анимации
                animateButton.disabled = false;
            });

            // Animation button
            animateButton.addEventListener('click', function () {
                if (animationFrame) {
                    // Если анимация уже запущена, останавливаем её
                    cancelAnimationFrame(animationFrame);
                    animationFrame = null;
                    animateButton.textContent = 'Анимировать';
                    animateButton.disabled = false;
                } else {
                    // Запускаем анимацию
                    if (!strokeData || !strokeData.strokes) return;

                    // Блокируем кнопку во время анимации
                    animateButton.disabled = true;
                    animateButton.textContent = 'Анимация...';

                    // Очищаем холст перед началом анимации
                    strokesCtx.clearRect(0, 0, strokesCanvas.width, strokesCanvas.height);

                    // Сбрасываем индекс анимации
                    animationIndex = 0;

                    // Очищаем выделение
                    highlightCtx.clearRect(0, 0, highlightCanvas.width, highlightCanvas.height);
                    highlightedStrokeId = null;
                    updateDebugInfo(null);

                    // Запускаем анимацию
                    animationFrame = requestAnimationFrame(animateStrokes);
                }
            });

            // Update showGradients checkbox
            showGradientsCheckbox.addEventListener('change', function () {
                updateGradientsView();
            });

            // Update showCenters checkbox
            showCentersCheckbox.addEventListener('change', function () {
                updateGradientsView();
            });

            // Update showColorGradient checkbox
            showColorGradientCheckbox.addEventListener('change', function () {
                updateGradientsView();
                gradientSensitivityContainer.style.display = this.checked ? 'block' : 'none';
            });

            // Обновление значения чувствительности
            gradientSensitivitySlider.addEventListener('input', function () {
                gradientSensitivityValue.textContent = this.value;
                if (showColorGradientCheckbox.checked) {
                    updateGradientsView();
                }
            });

            // Function to animate strokes
            function animateStrokes() {
                if (animationIndex < strokeData.strokes.length) {
                    // Рисуем все мазки текущей цветовой группы
                    const currentGroup = strokeData.strokes[animationIndex].colorGroup;
                    let endIndex = animationIndex;

                    // Находим все мазки текущей цветовой группы
                    while (endIndex < strokeData.strokes.length &&
                        strokeData.strokes[endIndex].colorGroup === currentGroup) {
                        endIndex++;
                    }

                    // Рисуем мазки группы с учетом скорости анимации
                    let batchEndIndex = Math.min(animationIndex + animationSpeed, endIndex);

                    for (let i = animationIndex; i < batchEndIndex; i++) {
                        drawStroke(strokesCtx, strokeData.strokes[i]);
                    }

                    animationIndex = batchEndIndex;

                    // Если закончили группу и ещё есть место для других мазков этого кадра, сразу переходим к следующей группе
                    if (animationIndex === endIndex &&
                        endIndex < strokeData.strokes.length &&
                        (endIndex - animationIndex) < animationSpeed) {

                        // Продолжаем анимацию без задержки
                        animationFrame = requestAnimationFrame(animateStrokes);
                    } else {
                        // Продолжаем анимацию с задержкой между кадрами
                        setTimeout(() => {
                            animationFrame = requestAnimationFrame(animateStrokes);
                        }, 10); // Небольшая задержка между кадрами для плавности
                    }
                } else {
                    // Анимация завершена
                    animationFrame = null;
                    animateButton.disabled = false;
                    animateButton.textContent = 'Анимировать';

                    // Обновляем отображение центров кластеров, если включено
                    if (showCentersCheckbox.checked) {
                        drawClusterCenters(gradientsCtx, strokeData.strokes);
                    }
                }
            }

            // Function to draw a single stroke
            function drawStroke(ctx, stroke) {
                ctx.fillStyle = `rgb(${stroke.color[0]}, ${stroke.color[1]}, ${stroke.color[2]})`;

                // Draw each pixel in the stroke
                for (const pixel of stroke.pixels) {
                    // Масштабируем координаты
                    const x = Math.floor(pixel[0] * scaleX);
                    const y = Math.floor(pixel[1] * scaleY);

                    // Используем размер кисти в зависимости от масштаба
                    // Всегда рисуем кругом для сглаживания границ мазков
                    const brushSize = Math.max(1, Math.min(scaleX, scaleY));

                    // Всегда используем закругленную кисть для более эстетичного результата
                    ctx.beginPath();
                    // Используем радиус brushSize/2, минимум 0.5 для покрытия пикселя
                    ctx.arc(x + 0.5, y + 0.5, Math.max(0.5, brushSize / 2), 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Function to draw all strokes at once
            function drawAllStrokes(ctx, strokes) {
                for (const stroke of strokes) {
                    drawStroke(ctx, stroke);
                }
            }

            // Function to update statistics
            function updateStats(data) {
                // Определяем количество цветовых групп
                const numColorGroups = data.strokes.length > 0 ?
                    Math.max(...data.strokes.map(s => s.colorGroup)) + 1 : 0;

                statsDiv.innerHTML = `
                    Размер изображения: ${data.imageWidth} x ${data.imageHeight}<br>
                    Количество мазков: ${data.strokes.length}<br>
                    Количество цветовых групп: ${numColorGroups}<br>
                    Средний размер мазка: ${Math.round(data.strokes.reduce((sum, s) => sum + s.pixels.length, 0) / data.strokes.length)} пикселей<br>
                `;
            }

            // Add slider for animation speed
            const speedControl = document.createElement('div');
            speedControl.className = 'form-group';
            speedControl.innerHTML = `
                <label for="animationSpeed">Скорость анимации: <span id="animationSpeedValue" class="value-display">${animationSpeed}</span></label>
                <input type="range" id="animationSpeed" min="1" max="50" value="${animationSpeed}">
            `;

            document.querySelector('.animation-controls').parentNode.insertBefore(
                speedControl,
                document.querySelector('.animation-controls')
            );

            const speedSlider = document.getElementById('animationSpeed');
            const speedDisplay = document.getElementById('animationSpeedValue');

            speedSlider.addEventListener('input', function () {
                animationSpeed = parseInt(this.value);
                speedDisplay.textContent = animationSpeed;
            });

            // Function to draw gradient vectors
            function drawGradientVectors(ctx, vectors) {
                // Сначала копируем исходное изображение для контекста
                ctx.drawImage(originalCanvas, 0, 0);

                // Делаем изображение полупрозрачным
                ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);

                // Рисуем каждый вектор
                for (const vector of vectors) {
                    // Масштабируем координаты
                    const x = Math.floor(vector.x * scaleX);
                    const y = Math.floor(vector.y * scaleY);

                    // Вычисляем длину линии вектора (10-30 пикселей, зависит от magnitude)
                    const lineLength = 10 + vector.length * 20;

                    // Вычисляем конечную точку вектора
                    const endX = x + Math.cos(vector.theta) * lineLength;
                    const endY = y + Math.sin(vector.theta) * lineLength;

                    // Рисуем линию вектора
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    ctx.lineTo(endX, endY);
                    ctx.strokeStyle = 'rgba(0, 100, 255, 0.7)';
                    ctx.lineWidth = 1.5;
                    ctx.stroke();

                    // Рисуем наконечник стрелки
                    const arrowSize = 5;
                    const angle = vector.theta;

                    ctx.beginPath();
                    ctx.moveTo(endX, endY);
                    ctx.lineTo(
                        endX - arrowSize * Math.cos(angle - Math.PI / 6),
                        endY - arrowSize * Math.sin(angle - Math.PI / 6)
                    );
                    ctx.lineTo(
                        endX - arrowSize * Math.cos(angle + Math.PI / 6),
                        endY - arrowSize * Math.sin(angle + Math.PI / 6)
                    );
                    ctx.closePath();
                    ctx.fillStyle = 'rgba(0, 100, 255, 0.9)';
                    ctx.fill();

                    // Рисуем точку начала вектора
                    ctx.beginPath();
                    ctx.arc(x, y, 2, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(255, 0, 0, 0.7)';
                    ctx.fill();
                }
            }

            // Function to find the nearest stroke to the mouse position
            function findNearestStroke(mouseX, mouseY, strokes) {
                let nearestStroke = null;
                let minDistance = Infinity;
                const searchRadius = 20; // Search within 20px radius

                for (const stroke of strokes) {
                    // Scale center coordinates
                    const centerX = stroke.centerX * scaleX;
                    const centerY = stroke.centerY * scaleY;

                    const distance = Math.sqrt(Math.pow(mouseX - centerX, 2) + Math.pow(mouseY - centerY, 2));

                    if (distance < minDistance && distance < searchRadius) {
                        minDistance = distance;
                        nearestStroke = stroke;
                    }
                }
                return nearestStroke;
            }

            // Function to update debug info panel
            function updateDebugInfo(stroke) {
                if (!stroke) {
                    clusterDebugDiv.textContent = 'Наведите курсор на мазок для отладки...';
                    return;
                }

                const thetaDeg = (stroke.theta * 180 / Math.PI).toFixed(1);
                const numPixels = stroke.pixels ? stroke.pixels.length : 0;
                const aspectRatio = stroke.width > 0 ? (stroke.height / stroke.width).toFixed(2) : 'N/A';

                clusterDebugDiv.innerHTML = `
                    <strong>Кластер ID:</strong> ${stroke.id}<br>
                    <strong>Центр X:</strong> ${stroke.centerX.toFixed(1)}<br>
                    <strong>Центр Y:</strong> ${stroke.centerY.toFixed(1)}<br>
                    <strong>Угол (Theta):</strong> ${thetaDeg}°<br>
                    <strong>Когерентность Theta:</strong> ${stroke.thetaCoherence ? stroke.thetaCoherence.toFixed(3) : 'N/A'}<br>
                    <strong>Пикселей:</strong> ${numPixels}<br>
                    <strong>Ширина:</strong> ${stroke.width.toFixed(1)}<br>
                    <strong>Высота:</strong> ${stroke.height.toFixed(1)}<br>
                    <strong>Соотношение ШхВ:</strong> ${aspectRatio}
                `;
            }

            // Function to draw highlight (bounding box and vector)
            function drawStrokeHighlight(ctx, stroke) {
                if (!stroke) return;

                // Clear previous highlight
                ctx.clearRect(0, 0, highlightCanvas.width, highlightCanvas.height);

                // --- Draw Bounding Box --- 
                const scaledMinX = Math.floor(stroke.minX * scaleX);
                const scaledMinY = Math.floor(stroke.minY * scaleY);
                const scaledMaxX = Math.ceil(stroke.maxX * scaleX);
                const scaledMaxY = Math.ceil(stroke.maxY * scaleY);
                const boxWidth = scaledMaxX - scaledMinX;
                const boxHeight = scaledMaxY - scaledMinY;

                ctx.strokeStyle = 'rgba(255, 0, 0, 0.8)'; // Red color for highlight
                ctx.lineWidth = 1;
                ctx.strokeRect(scaledMinX, scaledMinY, boxWidth, boxHeight);

                // --- Draw Orientation Vector --- 
                const centerX = stroke.centerX * scaleX;
                const centerY = stroke.centerY * scaleY;
                const vectorLength = 30; // Length of the vector to draw
                const angle = stroke.theta; // Angle from the stroke data
                const endX = centerX + Math.cos(angle) * vectorLength;
                const endY = centerY + Math.sin(angle) * vectorLength;

                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(endX, endY);
                ctx.strokeStyle = 'rgba(0, 255, 0, 0.9)'; // Green color for vector
                ctx.lineWidth = 2;
                ctx.stroke();

                // Draw a small circle at the start of the vector
                ctx.beginPath();
                ctx.arc(centerX, centerY, 3, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(0, 255, 0, 0.9)';
                ctx.fill();
            }

            // Event listener for mouse movement on strokes canvas
            strokesCanvas.addEventListener('mousemove', function (event) {
                if (!strokeData || !strokeData.strokes) return;

                const rect = strokesCanvas.getBoundingClientRect();
                const mouseX = event.clientX - rect.left;
                const mouseY = event.clientY - rect.top;

                const nearestStroke = findNearestStroke(mouseX, mouseY, strokeData.strokes);
                updateDebugInfo(nearestStroke);

                // Update highlight if the nearest stroke changed
                const newNearestId = nearestStroke ? nearestStroke.id : null;
                if (newNearestId !== highlightedStrokeId) {
                    highlightedStrokeId = newNearestId;
                    drawStrokeHighlight(highlightCtx, nearestStroke);
                }
            });

            strokesCanvas.addEventListener('mouseout', function () {
                updateDebugInfo(null); // Clear debug info when mouse leaves canvas
                highlightCtx.clearRect(0, 0, highlightCanvas.width, highlightCanvas.height); // Clear highlight
                highlightedStrokeId = null;
            });

            // Add reset event handlers to clear highlight
            form.addEventListener('submit', function () {
                highlightCtx.clearRect(0, 0, highlightCanvas.width, highlightCanvas.height);
                highlightedStrokeId = null;
                updateDebugInfo(null);
            });

            resetButton.addEventListener('click', function () {
                highlightCtx.clearRect(0, 0, highlightCanvas.width, highlightCanvas.height);
                highlightedStrokeId = null;
                updateDebugInfo(null);
            });

            animateButton.addEventListener('click', function () {
                highlightCtx.clearRect(0, 0, highlightCanvas.width, highlightCanvas.height);
                highlightedStrokeId = null;
                updateDebugInfo(null);
            });

            // Function to draw cluster centers
            function drawClusterCenters(ctx, strokes) {
                if (!strokes || strokes.length === 0) return;

                ctx.save();

                // Рисуем центры кластеров
                for (const stroke of strokes) {
                    const x = Math.floor(stroke.centerX * scaleX);
                    const y = Math.floor(stroke.centerY * scaleY);

                    // Рисуем крестик в центре кластера
                    const size = 5; // Размер крестика

                    ctx.beginPath();
                    // Горизонтальная линия
                    ctx.moveTo(x - size, y);
                    ctx.lineTo(x + size, y);
                    // Вертикальная линия
                    ctx.moveTo(x, y - size);
                    ctx.lineTo(x, y + size);

                    ctx.strokeStyle = 'rgba(255, 0, 0, 0.8)';
                    ctx.lineWidth = 2;
                    ctx.stroke();

                    // Рисуем маленький круг в центре
                    ctx.beginPath();
                    ctx.arc(x, y, 2, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(255, 255, 0, 0.9)';
                    ctx.fill();
                }

                ctx.restore();
            }

            function updateGradientsView() {
                if (!strokeData) return;

                // Clear the canvas
                gradientsCtx.clearRect(0, 0, gradientsCanvas.width, gradientsCanvas.height);

                // Start with the original image for context
                gradientsCtx.drawImage(originalCanvas, 0, 0);

                // Apply semi-transparent overlay
                gradientsCtx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                gradientsCtx.fillRect(0, 0, gradientsCanvas.width, gradientsCanvas.height);

                // Draw color gradient heatmap if option is checked
                if (showColorGradientCheckbox.checked && strokeData.gradientDebug) {
                    drawColorGradient(gradientsCtx, strokeData.gradientDebug);
                }

                // Draw gradient vectors if option is checked
                if (showGradientsCheckbox.checked && strokeData.gridVectors) {
                    drawGradientVectors(gradientsCtx, strokeData.gridVectors);
                }

                // Draw cluster centers if option is checked
                if (showCentersCheckbox.checked && strokeData.strokes) {
                    drawClusterCenters(gradientsCtx, strokeData.strokes);
                }
            }

            // Function to draw color gradient heatmap
            function drawColorGradient(ctx, gradientData) {
                const width = ctx.canvas.width;
                const height = ctx.canvas.height;

                // Create an ImageData object to draw the gradient
                const imageData = ctx.createImageData(width, height);
                const data = imageData.data;

                // Calculate scale factors if the canvas size is different from the gradient data
                const scaleFactorX = width / gradientData[0].length;
                const scaleFactorY = height / gradientData.length;

                // Get current sensitivity value
                const sensitivity = parseFloat(gradientSensitivitySlider.value);

                // Fill the image data with gradient values
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        // Map canvas coordinates to gradient data coordinates
                        const gradientX = Math.min(Math.floor(x / scaleFactorX), gradientData[0].length - 1);
                        const gradientY = Math.min(Math.floor(y / scaleFactorY), gradientData.length - 1);

                        // Get gradient value at this point (0.0-1.0)
                        let value = gradientData[gradientY][gradientX];

                        // Apply sensitivity adjustment
                        if (sensitivity !== 1.0) {
                            // For sensitivity < 1.0: enhance low values (make weak gradients more visible)
                            // For sensitivity > 1.0: enhance high values (make strong gradients stand out more)
                            value = Math.pow(value, 1.0 / sensitivity);

                            // Keep value in 0-1 range
                            value = Math.max(0, Math.min(1, value));
                        }

                        // Use a more vibrant heat map color scheme (magenta-yellow-cyan)
                        let r, g, b;

                        if (value < 0.33) {
                            // Magenta to yellow (low to medium-low)
                            const t = value * 3;
                            r = 255;
                            g = Math.floor(255 * t);
                            b = Math.floor(255 * (1 - t));
                        } else if (value < 0.66) {
                            // Yellow to white (medium-low to medium-high)
                            const t = (value - 0.33) * 3;
                            r = 255;
                            g = 255;
                            b = Math.floor(255 * t);
                        } else {
                            // White to cyan (medium-high to high)
                            const t = (value - 0.66) * 3;
                            r = Math.floor(255 * (1 - t));
                            g = 255;
                            b = 255;
                        }

                        // Compute the pixel index
                        const idx = (y * width + x) * 4;

                        // Set pixel data with higher opacity
                        data[idx] = r;     // Red
                        data[idx + 1] = g; // Green
                        data[idx + 2] = b; // Blue
                        data[idx + 3] = 200; // Alpha (more opaque for better visibility)
                    }
                }

                // Put the image data on the canvas
                ctx.putImageData(imageData, 0, 0);

                // Add a legend for the gradient
                drawGradientLegend(ctx, width, height, sensitivity);
            }

            // Function to draw a legend for the gradient visualization
            function drawGradientLegend(ctx, width, height, sensitivity) {
                const legendWidth = 200;
                const legendHeight = 20;
                const legendX = width - legendWidth - 10;
                const legendY = height - legendHeight - 10;

                // Draw the gradient bar
                const gradientBar = ctx.createLinearGradient(legendX, 0, legendX + legendWidth, 0);
                gradientBar.addColorStop(0, "rgba(255, 0, 255, 0.9)"); // Magenta (low)
                gradientBar.addColorStop(0.33, "rgba(255, 255, 0, 0.9)"); // Yellow (medium-low)
                gradientBar.addColorStop(0.66, "rgba(255, 255, 255, 0.9)"); // White (medium-high)
                gradientBar.addColorStop(1, "rgba(0, 255, 255, 0.9)"); // Cyan (high)

                ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
                ctx.fillRect(legendX - 2, legendY - 2, legendWidth + 4, legendHeight + 4);

                ctx.fillStyle = gradientBar;
                ctx.fillRect(legendX, legendY, legendWidth, legendHeight);

                // Draw labels
                ctx.fillStyle = "white";
                ctx.font = "12px Arial";
                ctx.fillText(`Слабый градиент (x${sensitivity.toFixed(1)})`, legendX, legendY - 5);
                ctx.fillText("Сильный градиент", legendX + legendWidth - 100, legendY - 5);
            }
        });
    </script>
</body>

</html>